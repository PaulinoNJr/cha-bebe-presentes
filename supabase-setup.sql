-- Execute este script no Supabase SQL Editor.
-- Ele cria/ajusta estrutura, view, funcao RPC e RLS para o projeto.

create extension if not exists pgcrypto;

create table if not exists public.gifts (
  id bigint generated by default as identity primary key,
  title text not null check (char_length(trim(title)) >= 2),
  description text,
  image_url text,
  buy_url text,
  price_value numeric(12,2),
  price_manual_override boolean not null default false,
  price_status text not null default 'pending'
    check (price_status in ('pending', 'ok', 'failed', 'manual')),
  price_last_error text,
  price_checked_at timestamptz,
  is_active boolean not null default true,
  display_order integer not null default 0 check (display_order >= 0),
  qty_total integer not null check (qty_total > 0),
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

alter table public.gifts
  add column if not exists created_at timestamptz not null default now();

alter table public.gifts
  add column if not exists updated_at timestamptz not null default now();

alter table public.gifts
  add column if not exists price_value numeric(12,2);

alter table public.gifts
  add column if not exists price_manual_override boolean not null default false;

alter table public.gifts
  add column if not exists price_status text not null default 'pending';

alter table public.gifts
  add column if not exists price_last_error text;

alter table public.gifts
  add column if not exists price_checked_at timestamptz;

alter table public.gifts
  add column if not exists is_active boolean not null default true;

alter table public.gifts
  add column if not exists display_order integer not null default 0;

do $$
begin
  if not exists (
    select 1
    from pg_constraint
    where conname = 'gifts_display_order_nonnegative'
      and conrelid = 'public.gifts'::regclass
  ) then
    alter table public.gifts
      add constraint gifts_display_order_nonnegative
      check (display_order >= 0);
  end if;
end $$;

do $$
begin
  if not exists (
    select 1
    from pg_constraint
    where conname = 'gifts_price_status_valid'
      and conrelid = 'public.gifts'::regclass
  ) then
    alter table public.gifts
      add constraint gifts_price_status_valid
      check (price_status in ('pending', 'ok', 'failed', 'manual'));
  end if;
end $$;

create table if not exists public.gift_classifications (
  id bigint generated by default as identity primary key,
  name text not null check (char_length(trim(name)) >= 2),
  display_order integer not null default 0 check (display_order >= 0),
  created_at timestamptz not null default now()
);

create table if not exists public.site_content (
  id smallint primary key check (id = 1),
  instructions_html text not null default '',
  updated_at timestamptz not null default now()
);

insert into public.site_content (id, instructions_html)
values (1, '')
on conflict (id) do nothing;

create unique index if not exists ux_gift_classifications_name_lower
  on public.gift_classifications(lower(name));

alter table public.gift_classifications
  add column if not exists display_order integer not null default 0;

do $$
begin
  if not exists (
    select 1
    from pg_constraint
    where conname = 'gift_classifications_display_order_nonnegative'
      and conrelid = 'public.gift_classifications'::regclass
  ) then
    alter table public.gift_classifications
      add constraint gift_classifications_display_order_nonnegative
      check (display_order >= 0);
  end if;
end $$;

alter table public.gifts
  add column if not exists classification_id bigint references public.gift_classifications(id) on delete set null;

create index if not exists idx_gifts_classification_id
  on public.gifts(classification_id);

create index if not exists idx_gifts_is_active
  on public.gifts(is_active);

create index if not exists idx_gift_classifications_order
  on public.gift_classifications(display_order, name, id);

create index if not exists idx_gifts_classification_order
  on public.gifts(classification_id, display_order, id);

create table if not exists public.gift_reservations (
  id bigint generated by default as identity primary key,
  gift_id bigint not null references public.gifts(id) on delete cascade,
  reserved_by text not null check (char_length(trim(reserved_by)) >= 3),
  reserved_by_cpf text,
  reserved_by_cpf_hash text,
  qty integer not null check (qty > 0),
  reserved_at timestamptz not null default now()
);

alter table public.gift_reservations
  add column if not exists reserved_by_cpf text;

alter table public.gift_reservations
  add column if not exists reserved_by_cpf_hash text;

alter table public.gift_reservations
  alter column reserved_by_cpf drop not null;

do $$
begin
  if not exists (
    select 1
    from pg_constraint
    where conname = 'gift_reservations_cpf_digits'
      and conrelid = 'public.gift_reservations'::regclass
  ) then
    alter table public.gift_reservations
      add constraint gift_reservations_cpf_digits
      check (reserved_by_cpf is null or reserved_by_cpf ~ '^[0-9]{11}$');
  end if;
end $$;

do $$
begin
  if not exists (
    select 1
    from pg_constraint
    where conname = 'gift_reservations_cpf_hash_hex'
      and conrelid = 'public.gift_reservations'::regclass
  ) then
    alter table public.gift_reservations
      add constraint gift_reservations_cpf_hash_hex
      check (reserved_by_cpf_hash is null or reserved_by_cpf_hash ~ '^[0-9a-f]{64}$');
  end if;
end $$;

update public.gift_reservations
set reserved_by_cpf_hash = encode(digest(regexp_replace(reserved_by_cpf, '\D', '', 'g'), 'sha256'), 'hex')
where reserved_by_cpf_hash is null
  and reserved_by_cpf is not null
  and reserved_by_cpf ~ '^[0-9]{11}$';

update public.gift_reservations
set reserved_by_cpf = null
where reserved_by_cpf is not null
  and reserved_by_cpf_hash is not null;

create index if not exists idx_gift_reservations_gift_id
  on public.gift_reservations(gift_id);

create index if not exists idx_gift_reservations_reserved_at
  on public.gift_reservations(reserved_at desc);

create table if not exists public.reservation_cancel_attempts (
  id bigint generated by default as identity primary key,
  reservation_id bigint not null references public.gift_reservations(id) on delete cascade,
  success boolean not null default false,
  created_at timestamptz not null default now()
);

create index if not exists idx_cancel_attempts_reservation_time
  on public.reservation_cancel_attempts(reservation_id, created_at desc);

-- Bloco defensivo para execucao parcial do script
create table if not exists public.gift_classifications (
  id bigint generated by default as identity primary key,
  name text not null check (char_length(trim(name)) >= 2),
  display_order integer not null default 0 check (display_order >= 0),
  created_at timestamptz not null default now()
);

alter table public.gifts
  add column if not exists classification_id bigint references public.gift_classifications(id) on delete set null;

drop view if exists public.gifts_view;

create view public.gifts_view as
select
  g.id,
  g.title,
  g.description,
  g.image_url,
  g.buy_url,
  g.price_value,
  g.price_manual_override,
  g.price_status,
  g.price_last_error,
  g.price_checked_at,
  g.is_active,
  g.display_order,
  g.classification_id,
  c.display_order as classification_display_order,
  c.name as classification_name,
  g.qty_total,
  coalesce(sum(r.qty), 0)::integer as qty_reserved,
  greatest(g.qty_total - coalesce(sum(r.qty), 0), 0)::integer as qty_available
from public.gifts g
left join public.gift_classifications c on c.id = g.classification_id
left join public.gift_reservations r on r.gift_id = g.id
group by g.id, c.id, c.name, c.display_order;

create table if not exists public.admin_emails (
  email text primary key check (position('@' in email) > 1),
  created_at timestamptz not null default now()
);

create table if not exists public.price_update_settings (
  id smallint primary key check (id = 1),
  is_enabled boolean not null default false,
  frequency_minutes integer not null default 1440 check (frequency_minutes >= 60),
  next_run_at timestamptz,
  last_run_at timestamptz,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

insert into public.price_update_settings (id, is_enabled, frequency_minutes, next_run_at)
values (1, false, 1440, null)
on conflict (id) do nothing;

create table if not exists public.price_update_queue (
  id bigint generated by default as identity primary key,
  gift_id bigint not null references public.gifts(id) on delete cascade,
  buy_url text not null,
  status text not null default 'pending'
    check (status in ('pending', 'processing', 'done', 'failed')),
  attempts integer not null default 0 check (attempts >= 0),
  scheduled_for timestamptz not null default now(),
  detected_price numeric(12,2),
  last_error text,
  started_at timestamptz,
  finished_at timestamptz,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

create index if not exists idx_price_update_queue_status_schedule
  on public.price_update_queue(status, scheduled_for, id);

create index if not exists idx_price_update_queue_gift
  on public.price_update_queue(gift_id, id desc);

create unique index if not exists ux_price_update_queue_pending_per_gift
  on public.price_update_queue(gift_id)
  where status in ('pending', 'processing');

create table if not exists public.admin_audit_log (
  id bigint generated by default as identity primary key,
  created_at timestamptz not null default now(),
  actor_uid uuid,
  actor_email text,
  actor_role text,
  action text not null check (action in ('insert', 'update', 'delete')),
  entity_type text not null,
  entity_id text,
  payload jsonb
);

create index if not exists idx_admin_audit_log_created_at
  on public.admin_audit_log(created_at desc);

create index if not exists idx_admin_audit_log_entity
  on public.admin_audit_log(entity_type, entity_id, created_at desc);

create or replace function public.is_admin()
returns boolean
language sql
stable
security definer
set search_path = public
as $$
  select exists (
    select 1
    from public.admin_emails a
    where lower(a.email) = lower(coalesce(auth.jwt() ->> 'email', ''))
  );
$$;

create or replace function public.set_updated_at()
returns trigger
language plpgsql
as $$
begin
  new.updated_at = now();
  return new;
end;
$$;

create or replace function public.normalize_gift_title()
returns trigger
language plpgsql
as $$
begin
  new.title = upper(trim(coalesce(new.title, '')));
  return new;
end;
$$;

drop trigger if exists trg_gifts_updated_at on public.gifts;
create trigger trg_gifts_updated_at
before update on public.gifts
for each row
execute function public.set_updated_at();

drop trigger if exists trg_gifts_normalize_title on public.gifts;
create trigger trg_gifts_normalize_title
before insert or update on public.gifts
for each row
execute function public.normalize_gift_title();

drop trigger if exists trg_price_update_settings_updated_at on public.price_update_settings;
create trigger trg_price_update_settings_updated_at
before update on public.price_update_settings
for each row
execute function public.set_updated_at();

drop trigger if exists trg_price_update_queue_updated_at on public.price_update_queue;
create trigger trg_price_update_queue_updated_at
before update on public.price_update_queue
for each row
execute function public.set_updated_at();

update public.gifts
set title = upper(trim(title))
where title is not null
  and title <> upper(trim(title));

create or replace function public.is_valid_cpf(p_cpf text)
returns boolean
language plpgsql
immutable
as $$
declare
  v_cpf text := regexp_replace(coalesce(p_cpf, ''), '\D', '', 'g');
  v_sum integer := 0;
  v_d1 integer;
  v_d2 integer;
  i integer;
begin
  if v_cpf !~ '^[0-9]{11}$' then
    return false;
  end if;

  if v_cpf ~ '^(\d)\1{10}$' then
    return false;
  end if;

  v_sum := 0;
  for i in 1..9 loop
    v_sum := v_sum + substr(v_cpf, i, 1)::integer * (11 - i);
  end loop;
  v_d1 := (v_sum * 10) % 11;
  if v_d1 = 10 then
    v_d1 := 0;
  end if;
  if v_d1 <> substr(v_cpf, 10, 1)::integer then
    return false;
  end if;

  v_sum := 0;
  for i in 1..10 loop
    v_sum := v_sum + substr(v_cpf, i, 1)::integer * (12 - i);
  end loop;
  v_d2 := (v_sum * 10) % 11;
  if v_d2 = 10 then
    v_d2 := 0;
  end if;

  return v_d2 = substr(v_cpf, 11, 1)::integer;
end;
$$;

create or replace function public.hash_cpf(p_cpf text)
returns text
language sql
immutable
as $$
  select encode(digest(regexp_replace(coalesce(p_cpf, ''), '\D', '', 'g'), 'sha256'), 'hex');
$$;

create or replace function public.sanitize_audit_row(p_row jsonb)
returns jsonb
language sql
immutable
as $$
  select coalesce(p_row, '{}'::jsonb) - 'reserved_by_cpf' - 'reserved_by_cpf_hash';
$$;

create or replace function public.log_admin_audit()
returns trigger
language plpgsql
security definer
set search_path = public
as $$
declare
  v_action text;
  v_entity_id text;
  v_payload jsonb;
begin
  if tg_op = 'INSERT' then
    v_action := 'insert';
    v_entity_id := coalesce(new.id::text, null);
    v_payload := jsonb_build_object('new', public.sanitize_audit_row(to_jsonb(new)));
  elsif tg_op = 'UPDATE' then
    v_action := 'update';
    v_entity_id := coalesce(new.id::text, old.id::text, null);
    v_payload := jsonb_build_object(
      'old', public.sanitize_audit_row(to_jsonb(old)),
      'new', public.sanitize_audit_row(to_jsonb(new))
    );
  elsif tg_op = 'DELETE' then
    v_action := 'delete';
    v_entity_id := coalesce(old.id::text, null);
    v_payload := jsonb_build_object('old', public.sanitize_audit_row(to_jsonb(old)));
  else
    return coalesce(new, old);
  end if;

  insert into public.admin_audit_log (
    actor_uid,
    actor_email,
    actor_role,
    action,
    entity_type,
    entity_id,
    payload
  )
  values (
    auth.uid(),
    nullif(auth.jwt() ->> 'email', ''),
    coalesce(auth.role(), 'unknown'),
    v_action,
    tg_table_name,
    v_entity_id,
    v_payload
  );

  return coalesce(new, old);
end;
$$;

drop trigger if exists trg_audit_gifts on public.gifts;
create trigger trg_audit_gifts
after insert or update or delete on public.gifts
for each row
execute function public.log_admin_audit();

drop trigger if exists trg_audit_gift_classifications on public.gift_classifications;
create trigger trg_audit_gift_classifications
after insert or update or delete on public.gift_classifications
for each row
execute function public.log_admin_audit();

drop trigger if exists trg_audit_gift_reservations on public.gift_reservations;
create trigger trg_audit_gift_reservations
after insert or update or delete on public.gift_reservations
for each row
execute function public.log_admin_audit();

drop trigger if exists trg_audit_site_content on public.site_content;
create trigger trg_audit_site_content
after insert or update or delete on public.site_content
for each row
execute function public.log_admin_audit();

drop trigger if exists trg_audit_price_update_settings on public.price_update_settings;
create trigger trg_audit_price_update_settings
after insert or update or delete on public.price_update_settings
for each row
execute function public.log_admin_audit();

drop function if exists public.reserve_gift(bigint, text, integer);

create or replace function public.reserve_gift(
  p_gift_id bigint,
  p_name text,
  p_qty integer,
  p_cpf text
)
returns jsonb
language plpgsql
security definer
set search_path = public
as $$
declare
  v_name text := trim(coalesce(p_name, ''));
  v_cpf text := regexp_replace(coalesce(p_cpf, ''), '\D', '', 'g');
  v_cpf_hash text;
  v_qty integer := coalesce(p_qty, 0);
  v_total integer;
  v_is_active boolean;
  v_reserved integer;
begin
  if v_name !~ '\S+\s+\S+' then
    raise exception 'INVALID_NAME';
  end if;

  if public.is_valid_cpf(v_cpf) = false then
    raise exception 'INVALID_CPF';
  end if;
  v_cpf_hash := public.hash_cpf(v_cpf);

  if v_qty <= 0 then
    raise exception 'INVALID_QTY';
  end if;

  select g.qty_total, g.is_active
    into v_total, v_is_active
  from public.gifts g
  where g.id = p_gift_id
  for update;

  if not found then
    raise exception 'GIFT_NOT_FOUND';
  end if;

  if coalesce(v_is_active, true) = false then
    raise exception 'GIFT_INACTIVE';
  end if;

  select coalesce(sum(r.qty), 0)::integer
    into v_reserved
  from public.gift_reservations r
  where r.gift_id = p_gift_id;

  if (v_total - v_reserved) < v_qty then
    raise exception 'NOT_ENOUGH_QTY';
  end if;

  insert into public.gift_reservations (gift_id, reserved_by, reserved_by_cpf, reserved_by_cpf_hash, qty)
  values (p_gift_id, v_name, null, v_cpf_hash, v_qty);

  return jsonb_build_object('ok', true);
end;
$$;

create or replace function public.cancel_reservation(
  p_reservation_id bigint,
  p_cpf text
)
returns jsonb
language plpgsql
security definer
set search_path = public
as $$
declare
  v_cpf text := regexp_replace(coalesce(p_cpf, ''), '\D', '', 'g');
  v_cpf_hash text;
  v_saved_cpf text;
  v_saved_cpf_hash text;
  v_failed_attempts integer := 0;
begin
  select count(*)::integer
    into v_failed_attempts
  from public.reservation_cancel_attempts a
  where a.reservation_id = p_reservation_id
    and a.success = false
    and a.created_at > now() - interval '5 minutes';

  if coalesce(v_failed_attempts, 0) >= 5 then
    raise exception 'TOO_MANY_ATTEMPTS';
  end if;

  if public.is_valid_cpf(v_cpf) = false then
    raise exception 'INVALID_CPF';
  end if;
  v_cpf_hash := public.hash_cpf(v_cpf);

  select r.reserved_by_cpf, r.reserved_by_cpf_hash
    into v_saved_cpf, v_saved_cpf_hash
  from public.gift_reservations r
  where r.id = p_reservation_id
  for update;

  if not found then
    raise exception 'RESERVATION_NOT_FOUND';
  end if;

  if coalesce(v_saved_cpf_hash, '') <> '' then
    if v_saved_cpf_hash <> v_cpf_hash then
      insert into public.reservation_cancel_attempts (reservation_id, success)
      values (p_reservation_id, false);
      raise exception 'INVALID_CPF_RESERVATION';
    end if;
  elsif coalesce(v_saved_cpf, '') <> v_cpf then
    insert into public.reservation_cancel_attempts (reservation_id, success)
    values (p_reservation_id, false);
    raise exception 'INVALID_CPF_RESERVATION';
  end if;

  delete from public.gift_reservations
  where id = p_reservation_id;

  return jsonb_build_object('ok', true);
end;
$$;

create or replace function public.enqueue_price_refresh_all()
returns jsonb
language plpgsql
security definer
set search_path = public
as $$
declare
  v_inserted integer := 0;
  v_gift_ids bigint[] := '{}';
begin
  if coalesce(auth.role(), '') <> 'service_role' and public.is_admin() = false then
    raise exception 'NOT_ADMIN';
  end if;

  with inserted as (
    insert into public.price_update_queue (gift_id, buy_url, status, scheduled_for)
    select
      g.id,
      trim(g.buy_url),
      'pending',
      now()
    from public.gifts g
    where coalesce(g.is_active, true) = true
      and coalesce(g.price_manual_override, false) = false
      and coalesce(trim(g.buy_url), '') <> ''
      and not exists (
        select 1
        from public.price_update_queue q
        where q.gift_id = g.id
          and q.status in ('pending', 'processing')
      )
    returning gift_id
  )
  select coalesce(array_agg(i.gift_id), '{}'::bigint[]), count(*)::integer
    into v_gift_ids, v_inserted
  from inserted i;

  if v_inserted > 0 then
    update public.gifts g
    set
      price_status = 'pending',
      price_last_error = null
    where g.id = any(v_gift_ids)
      and coalesce(g.price_manual_override, false) = false;
  end if;

  return jsonb_build_object('ok', true, 'enqueued', v_inserted);
end;
$$;

create or replace function public.set_price_update_schedule(
  p_enabled boolean,
  p_frequency_minutes integer
)
returns jsonb
language plpgsql
security definer
set search_path = public
as $$
declare
  v_enabled boolean := coalesce(p_enabled, false);
  v_frequency integer := greatest(coalesce(p_frequency_minutes, 1440), 60);
  v_next_run timestamptz;
begin
  if coalesce(auth.role(), '') <> 'service_role' and public.is_admin() = false then
    raise exception 'NOT_ADMIN';
  end if;

  v_next_run := case
    when v_enabled then now() + make_interval(mins => v_frequency)
    else null
  end;

  insert into public.price_update_settings (id, is_enabled, frequency_minutes, next_run_at, updated_at)
  values (1, v_enabled, v_frequency, v_next_run, now())
  on conflict (id) do update
    set
      is_enabled = excluded.is_enabled,
      frequency_minutes = excluded.frequency_minutes,
      next_run_at = excluded.next_run_at,
      updated_at = now();

  return jsonb_build_object(
    'ok', true,
    'enabled', v_enabled,
    'frequency_minutes', v_frequency,
    'next_run_at', v_next_run
  );
end;
$$;

create or replace function public.enqueue_due_scheduled_price_updates()
returns jsonb
language plpgsql
security definer
set search_path = public
as $$
declare
  v_settings public.price_update_settings%rowtype;
  v_inserted integer := 0;
  v_gift_ids bigint[] := '{}';
begin
  if coalesce(auth.role(), '') <> 'service_role' and public.is_admin() = false then
    raise exception 'NOT_ADMIN';
  end if;

  select *
    into v_settings
  from public.price_update_settings
  where id = 1;

  if not found then
    return jsonb_build_object('ok', false, 'ran', false, 'reason', 'settings_missing');
  end if;

  if coalesce(v_settings.is_enabled, false) = false then
    return jsonb_build_object('ok', true, 'ran', false, 'reason', 'disabled');
  end if;

  if v_settings.next_run_at is not null and v_settings.next_run_at > now() then
    return jsonb_build_object(
      'ok', true,
      'ran', false,
      'reason', 'not_due',
      'next_run_at', v_settings.next_run_at
    );
  end if;

  with inserted as (
    insert into public.price_update_queue (gift_id, buy_url, status, scheduled_for)
    select
      g.id,
      trim(g.buy_url),
      'pending',
      now()
    from public.gifts g
    where coalesce(g.is_active, true) = true
      and coalesce(g.price_manual_override, false) = false
      and coalesce(trim(g.buy_url), '') <> ''
      and not exists (
        select 1
        from public.price_update_queue q
        where q.gift_id = g.id
          and q.status in ('pending', 'processing')
      )
    returning gift_id
  )
  select coalesce(array_agg(i.gift_id), '{}'::bigint[]), count(*)::integer
    into v_gift_ids, v_inserted
  from inserted i;

  if v_inserted > 0 then
    update public.gifts g
    set
      price_status = 'pending',
      price_last_error = null
    where g.id = any(v_gift_ids)
      and coalesce(g.price_manual_override, false) = false;
  end if;

  update public.price_update_settings
  set
    last_run_at = now(),
    next_run_at = now() + make_interval(mins => greatest(v_settings.frequency_minutes, 60)),
    updated_at = now()
  where id = 1;

  return jsonb_build_object('ok', true, 'ran', true, 'enqueued', v_inserted);
end;
$$;

create or replace function public.claim_price_update_jobs(p_limit integer default 20)
returns table (
  job_id bigint,
  gift_id bigint,
  buy_url text,
  attempts integer
)
language plpgsql
security definer
set search_path = public
as $$
begin
  if coalesce(auth.role(), '') <> 'service_role' and public.is_admin() = false then
    raise exception 'NOT_ADMIN';
  end if;

  return query
  with picked as (
    select q.id
    from public.price_update_queue q
    where q.status = 'pending'
      and q.scheduled_for <= now()
    order by q.scheduled_for asc, q.id asc
    for update skip locked
    limit greatest(coalesce(p_limit, 20), 1)
  ),
  upd as (
    update public.price_update_queue q
    set
      status = 'processing',
      attempts = q.attempts + 1,
      started_at = now(),
      updated_at = now()
    from picked
    where q.id = picked.id
    returning q.id, q.gift_id, q.buy_url, q.attempts
  )
  select upd.id, upd.gift_id, upd.buy_url, upd.attempts
  from upd;
end;
$$;

create or replace function public.finish_price_update_job(
  p_job_id bigint,
  p_price_value numeric,
  p_error_message text default null
)
returns jsonb
language plpgsql
security definer
set search_path = public
as $$
declare
  v_gift_id bigint;
  v_price numeric(12,2);
  v_error text;
begin
  if coalesce(auth.role(), '') <> 'service_role' and public.is_admin() = false then
    raise exception 'NOT_ADMIN';
  end if;

  select q.gift_id
    into v_gift_id
  from public.price_update_queue q
  where q.id = p_job_id
  for update;

  if not found then
    raise exception 'JOB_NOT_FOUND';
  end if;

  v_price := round(coalesce(p_price_value, 0)::numeric, 2);
  v_error := nullif(trim(coalesce(p_error_message, '')), '');

  if v_price > 0 then
    update public.gifts
    set
      price_value = v_price,
      price_status = 'ok',
      price_last_error = null,
      price_checked_at = now()
    where id = v_gift_id
      and coalesce(price_manual_override, false) = false;

    update public.price_update_queue
    set
      status = 'done',
      detected_price = v_price,
      last_error = null,
      finished_at = now(),
      updated_at = now()
    where id = p_job_id;

    return jsonb_build_object('ok', true, 'status', 'done', 'price', v_price);
  end if;

  update public.price_update_queue
  set
    status = 'failed',
    detected_price = null,
    last_error = coalesce(v_error, 'PRECO_NAO_ENCONTRADO'),
    finished_at = now(),
    updated_at = now()
  where id = p_job_id;

  update public.gifts
  set
    price_status = 'failed',
    price_last_error = coalesce(v_error, 'PRECO_NAO_ENCONTRADO'),
    price_checked_at = now()
  where id = v_gift_id
    and coalesce(price_manual_override, false) = false;

  return jsonb_build_object('ok', true, 'status', 'failed');
end;
$$;

alter table public.gifts enable row level security;
alter table public.gift_classifications enable row level security;
alter table public.gift_reservations enable row level security;
alter table public.site_content enable row level security;
alter table public.price_update_settings enable row level security;
alter table public.price_update_queue enable row level security;
alter table public.admin_audit_log enable row level security;
alter table public.reservation_cancel_attempts disable row level security;
alter table public.admin_emails disable row level security;

drop policy if exists gifts_public_select on public.gifts;
create policy gifts_public_select
on public.gifts
for select
to anon, authenticated
using (true);

drop policy if exists gifts_admin_write on public.gifts;
create policy gifts_admin_write
on public.gifts
for all
to authenticated
using (public.is_admin())
with check (public.is_admin());

drop policy if exists classifications_public_select on public.gift_classifications;
create policy classifications_public_select
on public.gift_classifications
for select
to anon, authenticated
using (true);

drop policy if exists classifications_admin_write on public.gift_classifications;
create policy classifications_admin_write
on public.gift_classifications
for all
to authenticated
using (public.is_admin())
with check (public.is_admin());

drop policy if exists site_content_public_select on public.site_content;
create policy site_content_public_select
on public.site_content
for select
to anon, authenticated
using (true);

drop policy if exists site_content_admin_write on public.site_content;
create policy site_content_admin_write
on public.site_content
for all
to authenticated
using (public.is_admin())
with check (public.is_admin());

drop policy if exists price_update_settings_admin_access on public.price_update_settings;
create policy price_update_settings_admin_access
on public.price_update_settings
for all
to authenticated
using (public.is_admin())
with check (public.is_admin());

drop policy if exists price_update_queue_admin_access on public.price_update_queue;
create policy price_update_queue_admin_access
on public.price_update_queue
for all
to authenticated
using (public.is_admin())
with check (public.is_admin());

drop policy if exists reservations_public_select on public.gift_reservations;
create policy reservations_public_select
on public.gift_reservations
for select
to anon, authenticated
using (true);

drop policy if exists reservations_admin_delete on public.gift_reservations;
create policy reservations_admin_delete
on public.gift_reservations
for delete
to authenticated
using (public.is_admin());

drop policy if exists admin_audit_log_admin_select on public.admin_audit_log;
create policy admin_audit_log_admin_select
on public.admin_audit_log
for select
to authenticated
using (public.is_admin());

revoke all on public.admin_emails from anon, authenticated;

grant usage on schema public to anon, authenticated;
grant select on public.gifts_view to anon, authenticated;
grant select on public.gifts to anon, authenticated;
grant select on public.gift_classifications to anon, authenticated;
grant select on public.gift_reservations to anon, authenticated;
grant select on public.site_content to anon, authenticated;
grant select on public.admin_audit_log to authenticated;
grant select on public.price_update_settings to authenticated;
grant select, insert, update, delete on public.price_update_queue to authenticated;
grant insert, update on public.gifts to authenticated;
grant insert, update, delete on public.gift_classifications to authenticated;
grant delete on public.gift_reservations to authenticated;
grant insert, update on public.site_content to authenticated;
revoke all on public.reservation_cancel_attempts from anon, authenticated;
revoke select(reserved_by_cpf, reserved_by_cpf_hash) on public.gift_reservations from anon, authenticated;
grant execute on function public.reserve_gift(bigint, text, integer, text) to anon, authenticated;
grant execute on function public.cancel_reservation(bigint, text) to anon, authenticated;
grant execute on function public.is_admin() to authenticated;
grant execute on function public.enqueue_price_refresh_all() to authenticated;
grant execute on function public.set_price_update_schedule(boolean, integer) to authenticated;
grant execute on function public.enqueue_due_scheduled_price_updates() to authenticated;
grant execute on function public.claim_price_update_jobs(integer) to authenticated;
grant execute on function public.finish_price_update_job(bigint, numeric, text) to authenticated;

do $$
begin
  if to_regclass('public.gifts_id_seq') is not null then
    execute 'grant usage, select on sequence public.gifts_id_seq to authenticated';
  end if;
  if to_regclass('public.gift_reservations_id_seq') is not null then
    execute 'grant usage, select on sequence public.gift_reservations_id_seq to authenticated';
  end if;
  if to_regclass('public.gift_classifications_id_seq') is not null then
    execute 'grant usage, select on sequence public.gift_classifications_id_seq to authenticated';
  end if;
  if to_regclass('public.price_update_queue_id_seq') is not null then
    execute 'grant usage, select on sequence public.price_update_queue_id_seq to authenticated';
  end if;
  if to_regclass('public.admin_audit_log_id_seq') is not null then
    execute 'grant usage, select on sequence public.admin_audit_log_id_seq to authenticated';
  end if;
end $$;

-- Depois de criar seu usuario admin no Supabase Auth:
-- insert into public.admin_emails(email) values ('seu-email@dominio.com') on conflict do nothing;
